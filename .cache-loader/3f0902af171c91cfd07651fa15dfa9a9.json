{"remainingRequest":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js??ref--5-0!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\tool\\SWTool.js","dependencies":[{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\tool\\SWTool.js","mtime":1531362881851},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\.babelrc","mtime":1526554899270},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1526631545426},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js","mtime":1519638534000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSceneToWorld = getSceneToWorld;\nexports.getWorldToScene = getWorldToScene;\nexports.Vector3ToVP = Vector3ToVP;\nexports.VPToVector3 = VPToVector3;\nexports.YPRToVector3 = YPRToVector3;\nexports.getNumberMax360 = getNumberMax360;\nexports.getDistance = getDistance;\nexports.getHfov = getHfov;\nexports.getWfov = getWfov;\nexports.getFaceTileMatrixWH = getFaceTileMatrixWH;\nexports.getPintIFScene = getPintIFScene;\nexports.getRandomColor = getRandomColor;\nexports.getWallProbeSurfaceAngle = getWallProbeSurfaceAngle;\nexports.getProbeSurfaceDistance = getProbeSurfaceDistance;\nexports.getPanoRealPoint = getPanoRealPoint;\nexports.getWallRealPoint = getWallRealPoint;\nexports.getJudgeOrZoom = getJudgeOrZoom;\nexports.getArrowsAngle = getArrowsAngle;\nexports.disposeNode = disposeNode;\nexports.getFullScreen = getFullScreen;\nexports.TextDiv = TextDiv;\nexports.delectTextDiv = delectTextDiv;\nexports.getFont = getFont;\nexports.setCameraAngle = setCameraAngle;\n\nvar _SWConstants = require('./SWConstants');\n\nvar constants = _interopRequireWildcard(_SWConstants);\n\nvar _SWViewGesture = require('./SWViewGesture');\n\nvar _SWViewGesture2 = _interopRequireDefault(_SWViewGesture);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/* global THREE,$*/\n\n/**所有共用方法 */\n\nvar TWEEN = require('@tweenjs/tween.js');\n\n/**\r\n * 屏幕坐标转世界坐标\r\n * @param {number} dx 鼠标X坐标\r\n * @param {number} dy 鼠标Y坐标\r\n */\nfunction getSceneToWorld(dx, dy) {\n\n    var mouse3D = new THREE.Vector3(dx / window.innerWidth * 2 - 1, -(dy / window.innerHeight) * 2 + 1, 0.5);\n\n    mouse3D.project(constants.camera);\n\n    return mouse3D;\n};\n\n/**\r\n * 世界坐标转屏幕坐标\r\n * @param {THREE.Vector3} v3 世界坐标\r\n */\nfunction getWorldToScene(v3) {\n\n    var vector = v3.clone();\n\n    var windowWidth = window.innerWidth;\n\n    var minWidth = 1280;\n\n    if (windowWidth < minWidth) {\n\n        windowWidth = minWidth;\n    }\n\n    var widthHalf = windowWidth / 2;\n\n    var heightHalf = window.innerHeight / 2;\n\n    vector.project(constants.camera);\n\n    vector.x = vector.x * widthHalf + widthHalf;\n\n    vector.y = -(vector.y * heightHalf) + heightHalf;\n\n    return vector;\n};\n\n/**\r\n * 三维坐标转视点坐标\r\n * @param {THREE.Vector3} v3 \r\n */\nfunction Vector3ToVP(v3) {\n    var yaw = Math.atan2(v3.x, v3.z);\n\n    var pitch = Math.atan2(v3.y, v3.x / Math.sin(yaw));\n\n    yaw = THREE.Math.radToDeg(yaw);\n\n    if (yaw < 0) {\n\n        yaw = 360 + yaw;\n    }\n    yaw = (yaw + 90) % 360;\n\n    var swvg = new _SWViewGesture2.default(yaw, THREE.Math.radToDeg(pitch), 0);\n\n    return swvg;\n};\n\n/**\r\n * 视点转三维坐标,P是从球面和Z轴的交点绕Y轴旋转theta，\r\n * 然后在Y轴和其本身组成的平面上绕其过原点的法向量旋转phi得到，那么点P的坐标如下:\r\n * x = r*cos(phi)*sin(theta);\r\n * y = r*sin(phi);\r\n * z = r*cos(phi)*cos(theta);\r\n * @param {SWViewGesture} vp 球面坐标 yaw,pitch\r\n */\nfunction VPToVector3(vp) {\n    var vec = new THREE.Vector3(0, 0, 0);\n\n    vec.y = Math.sin(THREE.Math.degToRad(vp.Pitch)) * constants.c_FaceDistance * 0.5;\n\n    var m = Math.cos(THREE.Math.degToRad(vp.Pitch)) * constants.c_FaceDistance * 0.5;\n\n    vec.x = Math.sin(THREE.Math.degToRad(vp.Yaw - 90)) * m;\n\n    vec.z = Math.cos(THREE.Math.degToRad(vp.Yaw - 90)) * m;\n\n    return vec;\n};\n\n/**\r\n * 相机看向球面坐标转三维坐标\r\n * @param {Number} yaw 经度\r\n * @param {Number} pitch 纬度\r\n */\nfunction YPRToVector3(yaw, pitch) {\n\n    var vec = new THREE.Vector3(0, 0, 0);\n\n    vec.y = Math.sin(THREE.Math.degToRad(pitch)) * constants.c_FaceDistance * 0.5;\n\n    var m = Math.cos(THREE.Math.degToRad(pitch)) * constants.c_FaceDistance * 0.5;\n\n    vec.x = Math.sin(THREE.Math.degToRad(yaw - 90)) * m;\n\n    vec.z = Math.cos(THREE.Math.degToRad(yaw - 90)) * m;\n\n    return vec;\n}\n\n/**\r\n * 让数值在0~360之间\r\n * @param {number} n \r\n */\nfunction getNumberMax360(n) {\n\n    n = n % 360;\n\n    if (n < 0) {\n\n        n = 360 + n;\n    }\n    return n;\n};\n\n/**\r\n * 两点距离\r\n * @param {number} x1 \r\n * @param {number} y1 \r\n * @param {number} x2 \r\n * @param {number} y2 \r\n */\nfunction getDistance(x1, y1, x2, y2) {\n\n    var xx = x2 - x1;\n\n    var yy = y2 - y1;\n\n    return Math.pow(xx * xx + yy * yy, 0.5);\n};\n\n/**\r\n * 通过水平fov获得垂直fov\r\n * @param {number} wfov \r\n * @param {number} aspect \r\n */\nfunction getHfov(wfov, aspect) {\n\n    return THREE.Math.radToDeg(Math.atan(Math.tan(THREE.Math.degToRad(wfov) / 2) / aspect) * 2);\n};\n\n/**\r\n * 通过垂直fov获得水平fov\r\n * @param {number} hfov \r\n * @param {number} aspect \r\n */\nfunction getWfov(hfov, aspect) {\n\n    return THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(hfov) / 2) * aspect));\n};\n\n/**\r\n * 获取当前面当前放大值瓦片WH数\r\n * @param {number} lzoom \r\n */\nfunction getFaceTileMatrixWH(lzoom) {\n\n    var wh = new THREE.Vector3();\n\n    wh.x = wh.y = Math.pow(2, lzoom);\n\n    return wh;\n};\n\n/**\r\n * 获取点是否在屏幕上\r\n * @param {THREE.Vector3} sceneXY \r\n */\nfunction getPintIFScene(sceneXY) {\n    var boo = false;\n    if (Math.abs(sceneXY.x) != Infinity && sceneXY.x != NaN && sceneXY.x >= -100 && sceneXY.x <= window.innerWidth + 100 && Math.abs(sceneXY.y) != Infinity && sceneXY.y != NaN && window.innerHeight - sceneXY.y >= -100 && window.innerHeight - sceneXY.y <= window.innerHeight + 100 && Math.abs(sceneXY.z) != Infinity && sceneXY.z != NaN && sceneXY.z < 1) {\n        boo = true;\n    }\n    return boo;\n};\n\n/**\r\n * 获取随机颜色值\r\n * */\nfunction getRandomColor() {\n\n    return '#' + (Math.random() * 0xffffff << 0).toString(16);\n};\n\n/**\r\n * 墙面探面角度值\r\n * @param {THREE.Object} obj \r\n */\nfunction getWallProbeSurfaceAngle(obj) {\n\n    var normal = obj.face.normal.clone();\n\n    var vv = new THREE.Vector3(0, 0, 1);\n\n    var angle = THREE.Math.radToDeg(vv.angleTo(normal));\n\n    var tan = vv.clone().cross(normal).dot(new THREE.Vector3(0, 1, 0));\n\n    if (tan > 0) {\n\n        angle = 360 - angle;\n    }\n\n    return angle;\n};\n\n/**\r\n * 获取显示的距离\r\n * @param {THREE.Object} obj \r\n */\nfunction getProbeSurfaceDistance(obj) {\n\n    return Math.abs(1.5 * obj.distance / obj.point.y);\n};\n\n/**\r\n * 获取现实中的坐标\r\n * @param {THREE.Object} obj \r\n * @param {number} rph \r\n */\nfunction getPanoRealPoint(obj, rph) {\n\n    var v = Math.asin(obj.point.y / obj.distance); //垂直角度\n\n    var h = Math.atan2(obj.point.z, obj.point.x) - THREE.Math.degToRad(90); //水平角度\n\n    var rp = Math.abs(rph / Math.tan(v));\n\n    var x = rp * Math.cos(h);\n\n    var z = -rp * Math.sin(h);\n\n    var y = rph;\n\n    var v3 = new THREE.Vector3(x, y, z).applyMatrix4(constants.c_OpenGLToDS3Mx4);\n\n    var realPoint = constants.c_StationInfo.point.clone().add(v3);\n\n    return realPoint;\n};\n\n/**\r\n * 获得墙面点击的真实坐标\r\n * @param {THREE.Object} obj \r\n */\nfunction getWallRealPoint(obj) {\n\n    var drc = obj.point.clone().applyMatrix4(obj.object.matrix).applyMatrix4(constants.c_OpenGLToDS3Mx4);\n\n    var dx = drc.x / constants.c_WallDisplaySize * 2;\n\n    var dy = drc.y / constants.c_WallDisplaySize * 2;\n\n    var dz = drc.z / constants.c_WallDisplaySize * 2;\n\n    var realPoint = constants.c_StationInfo.point.clone().add(new THREE.Vector3(dx, dy, dz));\n\n    return realPoint;\n};\n\n/**\r\n * 获取是否跳转还是放大\r\n * @param {THREE.Object} obj 射线对象\r\n * @param {int} type 1-地面片检测 2-墙面片检测\r\n */\nfunction getJudgeOrZoom(obj, type) {\n\n    var distances = void 0;\n\n    var dis = 0;\n\n    if (type == 1) {\n\n        distances = getPanoRealPoint(obj, 2.5);\n\n        dis = -1;\n    } else {\n        distances = getWallRealPoint(obj);\n    }\n    var dis0 = Math.sqrt(Math.pow(distances.x - constants.c_StationInfo.nx, 2) + Math.pow(distances.y - constants.c_StationInfo.ny, 2)) + dis;\n\n    for (var i = 0; i < constants.c_AdjacentPanoInfoArr.length; i++) {\n\n        var dis1 = Math.sqrt(Math.pow(distances.x - constants.c_AdjacentPanoInfoArr[i].nX, 2) + Math.pow(distances.y - constants.c_AdjacentPanoInfoArr[i].nY, 2));\n\n        if (dis1 <= dis0) {\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\r\n * 获取两个站点坐标点的夹角\r\n * @param v1 当前站点\r\n * @param v2 下一站点\r\n * */\nfunction getArrowsAngle(v1, v2) {\n    var p2 = new THREE.Vector3(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z).applyMatrix4(constants.c_DS3ToOpenGLMx4);\n    var v4 = new THREE.Vector3(-1, 0, 0);\n    var angle = p2.angleTo(v4);\n    angle = THREE.Math.radToDeg(angle); //转换为角度\n    var tan = p2.clone().cross(v4).dot(new THREE.Vector3(0, 1, 0));\n    if (tan > 0) {\n        angle = 360 - angle;\n    }\n    return angle;\n};\n\n/**\r\n * 清空对象缓存\r\n * @param node 对象\r\n * @param ifParent 是否用父类删除自己\r\n * */\nfunction disposeNode(node) {\n    var ifParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (node instanceof THREE.Mesh || node instanceof THREE.Sprite || node instanceof THREE.Line || node instanceof THREE.BoxHelper) {\n        if (node.geometry) {\n            node.geometry.dispose();\n        }\n        if (node.material) {\n            if (node.material instanceof THREE.MeshFaceMaterial || node.material instanceof THREE.MultiMaterial) {\n                $.each(node.material.materials, function (idx, mtrl) {\n                    if (mtrl.map) mtrl.map.dispose();\n                    if (mtrl.lightMap) mtrl.lightMap.dispose();\n                    if (mtrl.bumpMap) mtrl.bumpMap.dispose();\n                    if (mtrl.normalMap) mtrl.normalMap.dispose();\n                    if (mtrl.specularMap) mtrl.specularMap.dispose();\n                    if (mtrl.envMap) mtrl.envMap.dispose();\n\n                    mtrl.dispose(); // disposes any programs associated with the material\n                });\n            } else {\n                if (node.material.map) node.material.map.dispose();\n                if (node.material.lightMap) node.material.lightMap.dispose();\n                if (node.material.bumpMap) node.material.bumpMap.dispose();\n                if (node.material.normalMap) node.material.normalMap.dispose();\n                if (node.material.specularMap) node.material.specularMap.dispose();\n                if (node.material.envMap) node.material.envMap.dispose();\n\n                node.material.dispose(); // disposes any programs associated with the material\n            }\n        }\n        if (ifParent) {\n            if (node.parent) {\n                node.parent.remove(node);\n            }\n            node = null;\n        }\n    }\n};\n\n/**\r\n * 全屏\r\n * */\nfunction getFullScreen() {\n    if (!document.fullscreenElement // alternative standard method\n    && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {\n        // current working methods\n        if (document.documentElement.requestFullscreen) {\n            document.documentElement.requestFullscreen();\n        } else if (document.documentElement.msRequestFullscreen) {\n            document.documentElement.msRequestFullscreen();\n        } else if (document.documentElement.mozRequestFullScreen) {\n            document.documentElement.mozRequestFullScreen();\n        } else if (document.documentElement.msRequestFullscreen) {\n            //IE11\n            document.documentElement.msRequestFullscreen();\n        } else if (document.documentElement.webkitRequestFullscreen) {\n            document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n        }\n    } else {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n        }\n    }\n};\n\n/**\r\n * DIV文本显示\r\n * @param {*} labelPos \r\n * @param {*} fontSize \r\n * @param {*} text \r\n */\nfunction TextDiv(labelPos, fontSize, text) {\n\n    labelPos.copy(getWorldToScene(labelPos));\n\n    this.textDiv = document.createElement(\"div\");\n\n    var fs = fontSize || 14;\n\n    this.textDiv.style.fontSize = fs + \"px\";\n\n    this.textDiv.style.color = \"#fff\";\n\n    this.textDiv.style.position = \"absolute\";\n\n    this.textDiv.id = \"\" + text;\n\n    this.textDiv.style.pointerEvents = \"none\";\n\n    if (!text) {\n\n        this.textDiv.style.left = \"-100px\";\n\n        this.textDiv.style.top = \"-100px\";\n    } else {\n\n        this.textDiv.style.left = labelPos.x + \"px\";\n\n        this.textDiv.style.top = labelPos.y + \"px\";\n    }\n    this.textDiv.innerHTML = text;\n\n    document.body.appendChild(this.textDiv);\n\n    return this.textDiv;\n}\n\n/**\r\n * 清楚新增文本div层\r\n * @param {*} textdiv \r\n */\nfunction delectTextDiv(textdiv) {\n\n    if (textdiv) {\n\n        document.body.removeChild(textdiv);\n    }\n}\n\n/**\r\n * 获取字体\r\n * @param {string} fontUrl 字体地址 '../../../commons/font/optimer_regular.typeface.json'\r\n * @param {Function} callFun 回调函数\r\n */\nfunction getFont(fontUrl) {\n    return new Promise(function (resolve, reject) {\n        var loader = new THREE.FontLoader();\n        loader.load(fontUrl, function (response) {\n            resolve(response);\n        });\n    });\n}\n\n/**\r\n * 设置相机视角\r\n * @param {Number} yaw 偏航角\r\n * @param {Number} pitch 俯仰角\r\n * @param {boolean} move 是否动画旋转\r\n */\nfunction setCameraAngle(yaw, pitch, move) {\n    if (move) {\n        var r1 = void 0,\n            r2 = void 0;\n        r1 = constants.sw_cameraManage.yaw_Camera - yaw;\n        if (r1 > 0) {\n            r2 = 360 - constants.sw_cameraManage.yaw_Camera + yaw;\n        } else {\n            r2 = 360 + constants.sw_cameraManage.yaw_Camera - yaw;\n        }\n\n        var from = {\n            x: constants.sw_cameraManage.yaw_Camera,\n            y: constants.sw_cameraManage.picth_Camera,\n            z: 0\n        };\n        var to = {\n            x: r1 > 0 ? Math.abs(r1) > Math.abs(r2) ? yaw + 360 : yaw : Math.abs(r1) > Math.abs(r2) ? yaw - 360 : yaw,\n            y: pitch,\n            z: 0\n        };\n        new TWEEN.Tween(from).to(to, 1000).easing(TWEEN.Easing.Exponential.Out).onUpdate(function () {\n            constants.sw_cameraManage.setHousesViewAngle(from.x, from.y);\n        }).onComplete(function () {\n            constants.sw_cameraManage.setHousesViewAngle(to.x, to.y);\n        }).start();\n    } else {\n        constants.sw_cameraManage.cameraLookAt(yaw, pitch);\n    }\n}",null]}