{"remainingRequest":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js?cacheDirectory=true!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","dependencies":[{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","mtime":1545731876374},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540192322431},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global THREE*/\n\nvar _SWConstants = require('../tool/SWConstants');\n\nvar _SWTool = require('../tool/SWTool');\n\nvar _store = require('../../views/redux/store/store');\n\nvar _store2 = _interopRequireDefault(_store);\n\nvar _action = require('../../views/redux/action');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TWEEN = require('@tweenjs/tween.js');\n\n/**\r\n * 相机控制类只有旋转和缩放，没有平移\r\n */\n\nvar SWCameraModule = function () {\n\tfunction SWCameraModule() {\n\t\t_classCallCheck(this, SWCameraModule);\n\n\t\t/**相机状态枚举 */\n\t\tthis.STATE = {\n\t\t\tNONE: -1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_DOLLY_PAN: 4\n\t\t};\n\n\t\t/**相机目前状态 */\n\t\tthis.state = this.STATE.NONE;\n\n\t\t/**鼠标按钮 */\n\t\tthis.mouseButtons = {\n\t\t\tORBIT: THREE.MOUSE.LEFT,\n\t\t\tZOOM: THREE.MOUSE.MIDDLE,\n\t\t\tPAN: THREE.MOUSE.RIGHT\n\t\t};\n\n\t\t//这个选项实际上可以使进出进入; 为了向后兼容，保留为“缩放”。\n\t\t/**设置为false以禁用缩放 */\n\t\tthis.enableZoom = true;\n\t\t/**缩放速度 */\n\t\tthis.zoomSpeed = 4.0;\n\n\t\t/**设置为false以禁用旋转 */\n\t\tthis.enableRotate = true;\n\t\t/**旋转速度 */\n\t\tthis.rotateSpeed = 0.4;\n\n\t\t//旋转坐标值\n\t\tthis.rotateStart = new THREE.Vector2();\n\t\tthis.rotateEnd = new THREE.Vector2();\n\t\tthis.rotateDelta = new THREE.Vector2();\n\n\t\tthis.startTime = 0;\n\n\t\tthis.speed = {\n\t\t\tyaw: 0,\n\t\t\tpitch: 0\n\t\t};\n\n\t\t//缩放坐标值\n\t\tthis.dollyStart = new THREE.Vector2();\n\t\tthis.dollyEnd = new THREE.Vector2();\n\t\tthis.dollyDelta = new THREE.Vector2();\n\n\t\tthis.rotateYaw = 0;\n\t\tthis.rotatePitch = 0;\n\n\t\t//围绕Y轴旋转，也叫偏航角\n\t\tthis.yaw_Camera = 0;\n\t\t//围绕X轴旋转，也叫做俯仰角\n\t\tthis.picth_Camera = 0;\n\t\t//围绕Z轴旋转，也叫翻滚角\n\t\tthis.roll_Camera = 0;\n\n\t\tthis.onPointerDownYaw = 0;\n\t\tthis.onPointerDownPitch = 0;\n\t\tthis.config = {\n\t\t\tyaw: 0,\n\t\t\tpitch: 0,\n\t\t\troll: 0,\n\t\t\ttouchPanSpeedCoeffFactor: 1\n\t\t};\n\t\tthis.prevTime;\n\n\t\t/***********************陀螺仪参数**************************** */\n\t\t/**是否启用陀螺仪 */\n\t\tthis.enabledGyro = true;\n\n\t\tthis.deviceOrientation = {};\n\t\tthis.screenOrientation = 0;\n\n\t\tthis.alphaOffset = 0; // radians\n\n\t\tthis.zee = new THREE.Vector3(0, 0, 1);\n\n\t\tthis.euler = new THREE.Euler();\n\n\t\tthis.q0 = new THREE.Quaternion();\n\n\t\tthis.q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\n\t\tthis.startAlpha = 0;\n\t\tthis.startBeta = 0;\n\t\tthis.startGamma = 0;\n\n\t\tthis.lon = this.lat = 0;\n\t\tthis.moothFactor = 10;\n\t\tthis.boundary = 320;\n\t\tthis.lastLon = this.lastLat = undefined;\n\n\t\t/**相机是否推进放大 */\n\t\tthis.ifCameraEnlarge = false;\n\n\t\t/**相机是否在缩放中 */\n\t\tthis.ifCameraRun = false;\n\n\t\tthis.store = (0, _store2.default)();\n\n\t\tthis.setHousesViewAngle(0, 0, true);\n\t}\n\n\t_createClass(SWCameraModule, [{\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\tthis.config.pitch = Math.max(_SWConstants.c_minPitch, Math.min(_SWConstants.c_maxPitch, this.config.pitch));\n\n\t\t\tthis.setHousesViewAngle(this.config.yaw, this.config.pitch);\n\n\t\t\tif (Math.abs(this.speed.yaw) > 0.01 || Math.abs(this.speed.pitch) > 0.01) {\n\n\t\t\t\tvar prevPitch = this.config.pitch;\n\t\t\t\tvar prevYaw = this.config.yaw;\n\n\t\t\t\tvar newTime = void 0;\n\t\t\t\tif (typeof performance !== 'undefined' && performance.now()) {\n\t\t\t\t\tnewTime = performance.now();\n\t\t\t\t} else {\n\t\t\t\t\tnewTime = Date.now();\n\t\t\t\t}\n\n\t\t\t\tif (this.prevTime === undefined) {\n\t\t\t\t\tthis.prevTime = newTime;\n\t\t\t\t}\n\n\t\t\t\tvar diff = (newTime - this.prevTime) * (_SWConstants.camera.fov + 32) / 1700;\n\t\t\t\tdiff = Math.min(diff, 1.0);\n\n\t\t\t\tthis.prevTime = newTime;\n\n\t\t\t\t// 惯性\n\t\t\t\tif (diff > 0) {\n\t\t\t\t\t// 摩擦\n\t\t\t\t\tvar friction = 0.85;\n\n\t\t\t\t\tthis.config.yaw += this.speed.yaw * diff * friction;\n\t\t\t\t\tthis.config.pitch += this.speed.pitch * diff * friction;\n\n\t\t\t\t\tthis.speed.yaw = this.speed.yaw * 0.8 + (this.config.yaw - prevYaw) / diff * 0.2;\n\t\t\t\t\tthis.speed.pitch = this.speed.pitch * 0.8 + (this.config.pitch - prevPitch) / diff * 0.2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.prevTime = undefined;\n\t\t\t}\n\t\t}\n\n\t\t/**设置缩放比例 */\n\n\t}, {\n\t\tkey: 'getZoomScale',\n\t\tvalue: function getZoomScale() {\n\t\t\treturn Math.pow(2, this.zoomSpeed);\n\t\t}\n\n\t\t/**缩小 */\n\n\t}, {\n\t\tkey: 'dollyIn',\n\t\tvalue: function dollyIn(dollyScale) {\n\t\t\tvar _this = this;\n\n\t\t\tvar fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov + dollyScale));\n\n\t\t\tvar from = {\n\t\t\t\tx: _SWConstants.camera.fov\n\t\t\t};\n\n\t\t\tvar to = {\n\t\t\t\tx: fov\n\t\t\t};\n\n\t\t\tnew TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n\t\t\t\t_SWConstants.camera.fov = this._object.x;\n\t\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\t\t\t}).onComplete(function () {\n\t\t\t\t_SWConstants.camera.fov = fov;\n\t\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\t\t\t\tif (_SWConstants.camera.fov > (_SWConstants.c_Maxfov + _SWConstants.c_Minfov) * 0.5) {\n\t\t\t\t\t_this.ifCameraEnlarge = false;\n\n\t\t\t\t\t_SWConstants.sw_skyBox.panoBox.clearFaceTiles();\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\n\t\t/**放大 */\n\n\t}, {\n\t\tkey: 'dollyOut',\n\t\tvalue: function dollyOut(dollyScale) {\n\t\t\tvar fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov - dollyScale));\n\n\t\t\tvar from = {\n\t\t\t\tx: _SWConstants.camera.fov\n\t\t\t};\n\n\t\t\tvar to = {\n\t\t\t\tx: fov\n\t\t\t};\n\n\t\t\tnew TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n\t\t\t\t_SWConstants.camera.fov = this._object.x;\n\n\t\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\t\t\t}).onComplete(function () {\n\t\t\t\t_SWConstants.camera.fov = fov;\n\n\t\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\t\t\t}).start();\n\t\t}\n\n\t\t/**\r\n   * 鼠标按下\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseDown',\n\t\tvalue: function onMouseDown(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tif (event.button == this.mouseButtons.ORBIT) {\n\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\tthis.rotateStart.set(event.clientX, event.clientY);\n\n\t\t\t\tthis.onPointerDownYaw = this.config.yaw;\n\t\t\t\tthis.onPointerDownPitch = this.config.pitch;\n\n\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\n\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\tthis.state = this.STATE.ROTATE;\n\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 鼠标移动\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseMove',\n\t\tvalue: function onMouseMove(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tif (this.state == this.STATE.ROTATE) {\n\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\tvar canvasWidth = window.innerWidth;\n\t\t\t\tvar canvasHeight = window.innerHeight;\n\n\t\t\t\tthis.rotateEnd.set(event.clientX, event.clientY);\n\n\t\t\t\tvar yaw = THREE.Math.radToDeg(Math.atan(this.rotateEnd.x / canvasWidth * 2 - 1) - Math.atan(this.rotateStart.x / canvasWidth * 2 - 1)) * ((_SWConstants.camera.fov + 32) / 90);\n\t\t\t\tthis.speed.yaw = yaw * 0.1 * _SWConstants.c_movingSpeedMultiple;\n\t\t\t\tthis.config.yaw += yaw;\n\n\t\t\t\tvar vfov = 2 * THREE.Math.radToDeg(Math.atan(Math.tan((_SWConstants.camera.fov + 32) / 360 * Math.PI) * canvasHeight / canvasWidth));\n\t\t\t\tvar pitch = THREE.Math.radToDeg(Math.atan(this.rotateEnd.y / canvasHeight * 2 - 1) - Math.atan(this.rotateStart.y / canvasHeight * 2 - 1)) * (vfov / 90);\n\n\t\t\t\tthis.speed.pitch = pitch * 0.1 * _SWConstants.c_movingSpeedMultiple;\n\t\t\t\tthis.config.pitch += pitch;\n\n\t\t\t\tthis.rotateStart.x = this.rotateEnd.x;\n\t\t\t\tthis.rotateStart.y = this.rotateEnd.y;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 鼠标弹起,旋转拖尾效果\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseUp',\n\t\tvalue: function onMouseUp(event) {\n\t\t\tif (this.state == this.STATE.ROTATE) {\n\n\t\t\t\tthis.state = this.STATE.NONE;\n\n\t\t\t\tif (Date.now() - this.startTime > 15) {\n\t\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 滚轮缩放\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseWheel',\n\t\tvalue: function onMouseWheel(event) {\n\t\t\tif (this.enableZoom === false || this.state !== this.STATE.NONE && this.state !== this.STATE.ROTATE) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tif (event.deltaY < 0) {\n\t\t\t\tthis.dollyOut(this.getZoomScale());\n\t\t\t} else if (event.deltaY > 0) {\n\t\t\t\tthis.dollyIn(this.getZoomScale());\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指按下\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchStart',\n\t\tvalue: function onTouchStart(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tswitch (event.touches.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\t// 单指触摸：旋转\n\t\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\t\tthis.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\t\tthis.config.roll = 0;\n\t\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\n\t\t\t\t\tthis.onPointerDownYaw = this.config.yaw;\n\t\t\t\t\tthis.onPointerDownPitch = this.config.pitch;\n\n\t\t\t\t\tthis.state = this.STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// 双指触摸：移动/缩放\n\t\t\t\t\tif (this.enableZoom === false && this.enablePan === false) return;\n\n\t\t\t\t\tif (this.enableZoom) {\n\t\t\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\t\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\t\t\tthis.dollyStart.set(0, distance);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.state = this.STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.state = this.STATE.NONE;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指移动\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchMove',\n\t\tvalue: function onTouchMove(event) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch (event.touches.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\t// 单指触摸：旋转\n\t\t\t\t\tif (this.enableRotate === false || this.state !== this.STATE.TOUCH_ROTATE) return;\n\n\t\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\t\tvar canvasWidth = window.innerWidth;\n\t\t\t\t\tvar canvasHeight = window.innerHeight;\n\n\t\t\t\t\tthis.rotateEnd.set(event.targetTouches[0].clientX, event.targetTouches[0].clientY);\n\n\t\t\t\t\tvar yaw = THREE.Math.radToDeg(Math.atan(this.rotateEnd.x / canvasWidth * 2 - 1) - Math.atan(this.rotateStart.x / canvasWidth * 2 - 1)) * ((_SWConstants.camera.fov + 32) / 90);\n\t\t\t\t\tthis.speed.yaw = yaw * 0.1 * _SWConstants.c_movingSpeedMultiple;\n\t\t\t\t\tthis.config.yaw += yaw;\n\n\t\t\t\t\tvar vfov = 2 * THREE.Math.radToDeg(Math.atan(Math.tan((_SWConstants.camera.fov + 32) / 360 * Math.PI) * canvasHeight / canvasWidth));\n\t\t\t\t\tvar pitch = THREE.Math.radToDeg(Math.atan(this.rotateEnd.y / canvasHeight * 2 - 1) - Math.atan(this.rotateStart.y / canvasHeight * 2 - 1)) * (vfov / 90);\n\n\t\t\t\t\tthis.speed.pitch = pitch * 0.1 * _SWConstants.c_movingSpeedMultiple;\n\t\t\t\t\tthis.config.pitch += pitch;\n\n\t\t\t\t\tthis.rotateStart.x = this.rotateEnd.x;\n\t\t\t\t\tthis.rotateStart.y = this.rotateEnd.y;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// 双指触摸：移动/缩放\n\t\t\t\t\tif (this.enableZoom === false || this.state !== this.STATE.TOUCH_DOLLY_PAN) return;\n\n\t\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\t\tthis.dollyEnd.set(0, distance);\n\n\t\t\t\t\tthis.dollyDelta.set(0, (this.dollyEnd.y - this.dollyStart.y) * 8 / this.zoomSpeed);\n\n\t\t\t\t\tthis.dollyIn(-this.dollyDelta.y);\n\n\t\t\t\t\tthis.dollyStart.copy(this.dollyEnd);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.state = this.STATE.NONE;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指弹起\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchEnd',\n\t\tvalue: function onTouchEnd(event) {\n\t\t\tif (event.touches.length === 1) {\n\t\t\t\tthis.state = this.STATE.TOUCH_ROTATE;\n\n\t\t\t\tthis.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t\t\tthis.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t\t} else if (event.touches.length === 0) {\n\t\t\t\tthis.state = this.STATE.NONE;\n\n\t\t\t\tif (Date.now() - this.startTime > 150) {\n\t\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\t\t\t\t}\n\t\t\t\tthis.startTime = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 有激光点云时点击墙面会放大\r\n   */\n\n\t}, {\n\t\tkey: 'setWallWheel',\n\t\tvalue: function setWallWheel() {\n\t\t\tif (_SWConstants.camera.isPerspectiveCamera) {\n\t\t\t\tif (_SWConstants.camera.fov > _SWConstants.c_Minfov) {\n\t\t\t\t\tthis.dollyOut((_SWConstants.c_Maxfov - _SWConstants.c_Minfov) / 3); //放大\n\t\t\t\t} else if (_SWConstants.camera.fov == _SWConstants.c_Minfov) {\n\t\t\t\t\tthis.dollyIn(100); //还原\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 这个是直接设置相机视角值\r\n   * @param {*} yaws 经度\r\n   * @param {*} pitch 纬度\r\n   * @param {*} updatas 更新坐标\r\n   */\n\n\t}, {\n\t\tkey: 'setHousesViewAngle',\n\t\tvalue: function setHousesViewAngle(yaws, pitch, updatas) {\n\t\t\tif (this.yaw_Camera == (0, _SWTool.getNumberMax360)(yaws) && this.picth_Camera == pitch) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (yaws || yaws == 0) this.yaw_Camera = (0, _SWTool.getNumberMax360)(yaws); //if(0) => false\n\n\t\t\tif (pitch || pitch == 0) this.picth_Camera = pitch;\n\n\t\t\tif (updatas) {\n\t\t\t\tthis.config.yaw = this.yaw_Camera;\n\t\t\t\tthis.config.pitch = this.picth_Camera;\n\t\t\t}\n\n\t\t\tthis.store.dispatch((0, _action.show_PanoMap_fun)({\n\t\t\t\tradarAngle: this.yaw_Camera\n\t\t\t}));\n\n\t\t\t_SWConstants.camera.lookAt((0, _SWTool.YPRToVector3)(this.yaw_Camera, this.picth_Camera));\n\n\t\t\t_SWConstants.sw_skyBox.panoBox.addFaceTiles();\n\t\t}\n\n\t\t/**\r\n   * 叠加相机角度\r\n   * @param {*} yaws 经度\r\n   * @param {*} pitch 纬度\r\n   */\n\n\t}, {\n\t\tkey: 'setOverlayViewAngle',\n\t\tvalue: function setOverlayViewAngle(yaws, pitch) {\n\t\t\tvar yawCamera = (0, _SWTool.getNumberMax360)(this.yaw_Camera + yaws);\n\n\t\t\tthis.setHousesViewAngle(yawCamera, pitch, true);\n\t\t}\n\t}]);\n\n\treturn SWCameraModule;\n}();\n\nexports.default = SWCameraModule;",null]}