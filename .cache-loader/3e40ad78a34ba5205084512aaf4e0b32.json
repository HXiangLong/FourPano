{"remainingRequest":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js?cacheDirectory=true!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","dependencies":[{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","mtime":1539658541217},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1540192322431},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global THREE*/\n\nvar _SWConstants = require('../tool/SWConstants');\n\nvar _SWTool = require('../tool/SWTool');\n\nvar _store = require('../../views/redux/store/store');\n\nvar _store2 = _interopRequireDefault(_store);\n\nvar _action = require('../../views/redux/action');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TWEEN = require('@tweenjs/tween.js');\n\n/**\r\n * 相机控制类只有旋转和缩放，没有平移\r\n */\n\nvar SWCameraModule = function () {\n\tfunction SWCameraModule() {\n\t\t_classCallCheck(this, SWCameraModule);\n\n\t\t/**相机状态枚举 */\n\t\tthis.STATE = {\n\t\t\tNONE: -1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_DOLLY_PAN: 4\n\t\t};\n\n\t\t/**相机目前状态 */\n\t\tthis.state = this.STATE.NONE;\n\n\t\t/**鼠标按钮 */\n\t\tthis.mouseButtons = {\n\t\t\tORBIT: THREE.MOUSE.LEFT,\n\t\t\tZOOM: THREE.MOUSE.MIDDLE,\n\t\t\tPAN: THREE.MOUSE.RIGHT\n\t\t};\n\n\t\t//这个选项实际上可以使进出进入; 为了向后兼容，保留为“缩放”。\n\t\t/**设置为false以禁用缩放 */\n\t\tthis.enableZoom = true;\n\t\t/**缩放速度 */\n\t\tthis.zoomSpeed = 4.0;\n\n\t\t/**设置为false以禁用旋转 */\n\t\tthis.enableRotate = true;\n\t\t/**旋转速度 */\n\t\tthis.rotateSpeed = 0.4;\n\n\t\t/**自动旋转 */\n\t\tthis.autoRotate = true;\n\t\t/**自动旋转速度，当fps为60时，每轮30秒 */\n\t\tthis.autoRotateSpeed = 2.0;\n\n\t\t//旋转坐标值\n\t\tthis.rotateStart = new THREE.Vector2();\n\t\tthis.rotateEnd = new THREE.Vector2();\n\t\tthis.rotateDelta = new THREE.Vector2();\n\n\t\tthis.startTime = 0;\n\n\t\tthis.speed = {\n\t\t\tyaw: 0,\n\t\t\tpitch: 0\n\t\t};\n\n\t\t//缩放坐标值\n\t\tthis.dollyStart = new THREE.Vector2();\n\t\tthis.dollyEnd = new THREE.Vector2();\n\t\tthis.dollyDelta = new THREE.Vector2();\n\n\t\tthis.rotateYaw = 0;\n\t\tthis.rotatePitch = 0;\n\n\t\t//围绕Y轴旋转，也叫偏航角\n\t\tthis.yaw_Camera = 0;\n\t\t//围绕X轴旋转，也叫做俯仰角\n\t\tthis.picth_Camera = 0;\n\t\t//围绕Z轴旋转，也叫翻滚角\n\t\tthis.roll_Camera = 0;\n\n\t\tthis.onPointerDownYaw = 0;\n\t\tthis.onPointerDownPitch = 0;\n\t\tthis.config = {\n\t\t\tyaw: 0,\n\t\t\tpitch: 0,\n\t\t\troll: 0,\n\t\t\ttouchPanSpeedCoeffFactor: 1\n\t\t};\n\t\tthis.prevTime;\n\t\tthis.animatedMove = {};\n\n\t\t/***********************陀螺仪参数**************************** */\n\t\t/**是否启用陀螺仪 */\n\t\tthis.enabledGyro = true;\n\n\t\tthis.deviceOrientation = {};\n\t\tthis.screenOrientation = 0;\n\n\t\tthis.alphaOffset = 0; // radians\n\n\t\tthis.zee = new THREE.Vector3(0, 0, 1);\n\n\t\tthis.euler = new THREE.Euler();\n\n\t\tthis.q0 = new THREE.Quaternion();\n\n\t\tthis.q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\n\t\tthis.startAlpha = 0;\n\t\tthis.startBeta = 0;\n\t\tthis.startGamma = 0;\n\n\t\tthis.lon = this.lat = 0;\n\t\tthis.moothFactor = 10;\n\t\tthis.boundary = 320;\n\t\tthis.lastLon = this.lastLat = undefined;\n\n\t\t/**相机是否推进放大 */\n\t\tthis.ifCameraEnlarge = false;\n\n\t\tthis.store = (0, _store2.default)();\n\n\t\tthis.setHousesViewAngle(0, 0, true);\n\t}\n\n\t_createClass(SWCameraModule, [{\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\n\t\t\tthis.config.pitch = Math.max(_SWConstants.c_minPitch, Math.min(_SWConstants.c_maxPitch, this.config.pitch));\n\n\t\t\tthis.setHousesViewAngle(this.config.yaw, this.config.pitch);\n\n\t\t\tif (Math.abs(this.speed.yaw) > 0.05 || Math.abs(this.speed.pitch) > 0.05) {\n\n\t\t\t\tvar prevPitch = this.config.pitch;\n\t\t\t\tvar prevYaw = this.config.yaw;\n\n\t\t\t\tvar newTime = void 0;\n\t\t\t\tif (typeof performance !== 'undefined' && performance.now()) {\n\t\t\t\t\tnewTime = performance.now();\n\t\t\t\t} else {\n\t\t\t\t\tnewTime = Date.now();\n\t\t\t\t}\n\t\t\t\tif (this.prevTime === undefined) {\n\t\t\t\t\tthis.prevTime = newTime;\n\t\t\t\t}\n\t\t\t\tvar diff = (newTime - this.prevTime) * (_SWConstants.camera.fov + 32) / 1700;\n\t\t\t\tdiff = Math.min(diff, 1.0);\n\n\t\t\t\t// 惯性\n\t\t\t\tif (diff > 0 && !this.autoRotate) {\n\t\t\t\t\t// 摩擦\n\t\t\t\t\tvar friction = 0.85;\n\n\t\t\t\t\t// Yaw\n\t\t\t\t\tif (!this.animatedMove.yaw) {\n\t\t\t\t\t\tthis.config.yaw += this.speed.yaw * diff * friction;\n\t\t\t\t\t}\n\t\t\t\t\t// Pitch\n\t\t\t\t\tif (!this.animatedMove.pitch) {\n\t\t\t\t\t\tthis.config.pitch += this.speed.pitch * diff * friction;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.prevTime = newTime;\n\t\t\t\tif (diff > 0) {\n\t\t\t\t\tthis.speed.yaw = this.speed.yaw * 0.8 + (this.config.yaw - prevYaw) / diff * 0.2;\n\t\t\t\t\tthis.speed.pitch = this.speed.pitch * 0.8 + (this.config.pitch - prevPitch) / diff * 0.2;\n\n\t\t\t\t\t// Limit speed\n\t\t\t\t\tvar maxSpeed = this.autoRotate ? Math.abs(this.autoRotate) : 5;\n\t\t\t\t\tthis.speed.yaw = Math.min(maxSpeed, Math.max(this.speed.yaw, -maxSpeed));\n\t\t\t\t\tthis.speed.pitch = Math.min(maxSpeed, Math.max(this.speed.pitch, -maxSpeed));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.prevTime = undefined;\n\t\t\t}\n\t\t}\n\n\t\t/**设置缩放比例 */\n\n\t}, {\n\t\tkey: 'getZoomScale',\n\t\tvalue: function getZoomScale() {\n\t\t\treturn Math.pow(2, this.zoomSpeed);\n\t\t}\n\n\t\t/**缩小 */\n\n\t}, {\n\t\tkey: 'dollyIn',\n\t\tvalue: function dollyIn(dollyScale) {\n\t\t\tvar _this = this;\n\n\t\t\tvar fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov + dollyScale));\n\n\t\t\tvar from = {\n\t\t\t\tx: _SWConstants.camera.fov\n\t\t\t};\n\n\t\t\tvar to = {\n\t\t\t\tx: fov\n\t\t\t};\n\n\t\t\tnew TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n\t\t\t\t_SWConstants.camera.fov = this._object.x;\n\t\t\t}).onComplete(function () {\n\t\t\t\tif (_SWConstants.camera.fov > (_SWConstants.c_Maxfov + _SWConstants.c_Minfov) * 0.5) {\n\n\t\t\t\t\t_this.ifCameraEnlarge = false;\n\n\t\t\t\t\t_SWConstants.sw_skyBox.panoBox.clearFaceTiles();\n\t\t\t\t}\n\t\t\t}).start();\n\n\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\t\t}\n\n\t\t/**放大 */\n\n\t}, {\n\t\tkey: 'dollyOut',\n\t\tvalue: function dollyOut(dollyScale) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov - dollyScale));\n\n\t\t\t_SWConstants.camera.updateProjectionMatrix();\n\n\t\t\tvar from = {\n\t\t\t\tx: _SWConstants.camera.fov\n\t\t\t};\n\n\t\t\tvar to = {\n\t\t\t\tx: fov\n\t\t\t};\n\n\t\t\tnew TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n\t\t\t\t_SWConstants.camera.fov = this._object.x;\n\t\t\t}).onComplete(function () {\n\n\t\t\t\tif (_SWConstants.camera.fov < (_SWConstants.c_Maxfov + _SWConstants.c_Minfov) * 0.5) {\n\n\t\t\t\t\t_this2.ifCameraEnlarge = true;\n\n\t\t\t\t\t_SWConstants.sw_skyBox.panoBox.addFaceTiles();\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\n\t\t/**\r\n   * 鼠标按下\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseDown',\n\t\tvalue: function onMouseDown(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tif (event.button == this.mouseButtons.ORBIT) {\n\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\tthis.rotateStart.set(event.clientX, event.clientY);\n\n\t\t\t\tthis.autoRotate = false;\n\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\n\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\tthis.onPointerDownYaw = this.config.yaw;\n\t\t\t\tthis.onPointerDownPitch = this.config.pitch;\n\n\t\t\t\tthis.state = this.STATE.ROTATE;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 鼠标移动\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseMove',\n\t\tvalue: function onMouseMove(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tif (this.state == this.STATE.ROTATE) {\n\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\tvar canvasWidth = window.innerWidth;\n\t\t\t\tvar canvasHeight = window.innerHeight;\n\n\t\t\t\tthis.rotateEnd.set(event.clientX, event.clientY);\n\n\t\t\t\tvar yaw = -((Math.atan(this.rotateStart.x / canvasWidth * 2 - 1) - Math.atan(this.rotateEnd.x / canvasWidth * 2 - 1)) * 180 / Math.PI * (_SWConstants.camera.fov + 32) / 90) + this.onPointerDownYaw;\n\t\t\t\tthis.speed.yaw = (yaw - this.config.yaw) % 360 * 0.3;\n\t\t\t\tthis.config.yaw = yaw;\n\n\t\t\t\tvar vfov = 2 * Math.atan(Math.tan((_SWConstants.camera.fov + 32) / 360 * Math.PI) * canvasHeight / canvasWidth) * 180 / Math.PI;\n\n\t\t\t\tvar pitch = (Math.atan(this.rotateEnd.y / canvasHeight * 2 - 1) - Math.atan(this.rotateStart.y / canvasHeight * 2 - 1)) * 180 / Math.PI * vfov / 90 + this.onPointerDownPitch;\n\t\t\t\tthis.speed.pitch = (pitch - this.config.pitch) * 0.3;\n\t\t\t\tthis.config.pitch = pitch;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 鼠标弹起,旋转拖尾效果\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseUp',\n\t\tvalue: function onMouseUp(event) {\n\t\t\tthis.state = this.STATE.NONE;\n\n\t\t\tif (Date.now() - this.startTime > 15) {\n\n\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\t\t\t}\n\n\t\t\tthis.latestInteraction = Date.now();\n\t\t}\n\n\t\t/**\r\n   * 滚轮缩放\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onMouseWheel',\n\t\tvalue: function onMouseWheel(event) {\n\t\t\tif (this.enableZoom === false || this.state !== this.STATE.NONE && this.state !== this.STATE.ROTATE) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tif (event.deltaY < 0) {\n\n\t\t\t\tthis.dollyOut(this.getZoomScale());\n\t\t\t} else if (event.deltaY > 0) {\n\n\t\t\t\tthis.dollyIn(this.getZoomScale());\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指按下\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchStart',\n\t\tvalue: function onTouchStart(event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tswitch (event.touches.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\t// 单指触摸：旋转\n\t\t\t\t\tif (this.enableRotate === false) return;\n\n\t\t\t\t\tthis.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\t\tthis.autoRotate = false;\n\t\t\t\t\tthis.config.roll = 0;\n\t\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\n\t\t\t\t\tthis.onPointerDownYaw = this.config.yaw;\n\t\t\t\t\tthis.onPointerDownPitch = this.config.pitch;\n\n\t\t\t\t\tthis.state = this.STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// 双指触摸：移动/缩放\n\t\t\t\t\tif (this.enableZoom === false && this.enablePan === false) return;\n\n\t\t\t\t\tif (this.enableZoom) {\n\t\t\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\t\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\t\t\tthis.dollyStart.set(0, distance);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.state = this.STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.state = this.STATE.NONE;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指移动\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchMove',\n\t\tvalue: function onTouchMove(event) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch (event.touches.length) {\n\t\t\t\tcase 1:\n\t\t\t\t\t// 单指触摸：旋转\n\t\t\t\t\tif (this.enableRotate === false || this.state !== this.STATE.TOUCH_ROTATE) return;\n\n\t\t\t\t\tthis.startTime = Date.now();\n\n\t\t\t\t\tthis.rotateEnd.set(event.targetTouches[0].clientX, event.targetTouches[0].clientY);\n\n\t\t\t\t\tvar touchmovePanSpeedCoeff = (_SWConstants.camera.fov + 32) / 360 * this.config.touchPanSpeedCoeffFactor;\n\n\t\t\t\t\tvar yaw = -(this.rotateStart.x - this.rotateEnd.x) * touchmovePanSpeedCoeff + this.onPointerDownYaw;\n\t\t\t\t\tthis.speed.yaw = (yaw - this.config.yaw) % 360 * 0.1;\n\t\t\t\t\tthis.config.yaw = yaw;\n\n\t\t\t\t\tvar pitch = (this.rotateEnd.y - this.rotateStart.y) * touchmovePanSpeedCoeff + this.onPointerDownPitch;\n\t\t\t\t\tthis.speed.pitch = (pitch - this.config.pitch) * 0.1;\n\t\t\t\t\tthis.config.pitch = pitch;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// 双指触摸：移动/缩放\n\t\t\t\t\tif (this.enableZoom === false || this.state !== this.STATE.TOUCH_DOLLY_PAN) return;\n\n\t\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\t\tthis.dollyEnd.set(0, distance);\n\n\t\t\t\t\tthis.dollyDelta.set(0, -(this.dollyEnd.y - this.dollyStart.y) * 0.5 / this.zoomSpeed);\n\n\t\t\t\t\tthis.dollyIn(this.dollyDelta.y);\n\n\t\t\t\t\tthis.dollyStart.copy(this.dollyEnd);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.state = this.STATE.NONE;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 手指弹起\r\n   * @param {MouseEvent} event \r\n   */\n\n\t}, {\n\t\tkey: 'onTouchEnd',\n\t\tvalue: function onTouchEnd(event) {\n\t\t\tif (event.touches.length === 1) {\n\t\t\t\tthis.state = this.STATE.TOUCH_ROTATE;\n\n\t\t\t\tthis.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t\t\tthis.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t\t} else if (event.touches.length === 0) {\n\n\t\t\t\tthis.state = this.STATE.NONE;\n\n\t\t\t\tif (Date.now() - this.startTime > 150) {\n\n\t\t\t\t\tthis.speed.pitch = this.speed.yaw = 0;\n\t\t\t\t}\n\t\t\t\tthis.startTime = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 监听并接收设备方向变化信息,检测手机倾斜旋转\r\n   *         z   \r\n   *         |   y\r\n   *         |  /   \r\n   *         | /\r\n   *          ————————X\r\n   * @param {*} event \r\n   */\n\n\t}, {\n\t\tkey: 'onDeviceOrientationChangeEvent',\n\t\tvalue: function onDeviceOrientationChangeEvent(event) {\n\t\t\tif (this.enabledGyro) {\n\t\t\t\tif (event) {\n\t\t\t\t\tvar alpha = event.alpha ? THREE.Math.degToRad(parseFloat((event.alpha - this.startAlpha).toFixed(2))) + this.alphaOffset : 0; // Z\n\n\t\t\t\t\tvar beta = event.beta ? THREE.Math.degToRad(parseFloat((event.beta - this.startBeta).toFixed(2))) : 0; // X'\n\n\t\t\t\t\tvar gamma = event.gamma ? THREE.Math.degToRad(parseFloat(event.gamma.toFixed(2))) : 0; // Y''\n\n\t\t\t\t\tvar orient = this.screenOrientation ? THREE.Math.degToRad(this.screenOrientation) : 0; // O\n\n\t\t\t\t\tthis.setObjectQuaternion(_SWConstants.camera.quaternion, alpha, beta, gamma, orient);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 浏览器横竖屏切换检测\r\n   */\n\n\t}, {\n\t\tkey: 'onScreenOrientationChangeEvent',\n\t\tvalue: function onScreenOrientationChangeEvent() {\n\t\t\tthis.screenOrientation = window.orientation || 0;\n\t\t}\n\n\t\t/**\r\n   * 重新定义相机的四元素\r\n   * @param {Quaternion} quaternion 相机的旋转四元素\r\n   * @param {Number} alpha 设备沿 Z 轴旋转的弧度值\r\n   * @param {Number} beta 设备在 x 轴上的旋转弧度值\r\n   * @param {Number} gamma 设备在 y 轴上的旋转弧度值\r\n   * @param {Number} orient 浏览器横竖屏朝向的弧度值\r\n   */\n\n\t}, {\n\t\tkey: 'setObjectQuaternion',\n\t\tvalue: function setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {\n\t\t\tthis.euler.set(beta, alpha, -gamma, 'YXZ'); //欧拉角是绕坐标轴旋转的角度和顺序,按照heading , pitch , roll 的顺序，应该是 YXZ\n\n\t\t\tquaternion.setFromEuler(this.euler); // 从欧拉角设置四元数\n\n\t\t\tquaternion.multiply(this.q1); //四元数的乘法\n\n\t\t\tquaternion.multiply(this.q0.setFromAxisAngle(this.zee, -orient)); // 从任意轴的旋转角设置四元数\n\t\t}\n\n\t\t/**\r\n   * 有激光点云时点击墙面会放大\r\n   */\n\n\t}, {\n\t\tkey: 'setWallWheel',\n\t\tvalue: function setWallWheel() {\n\n\t\t\tif (_SWConstants.camera.isPerspectiveCamera) {\n\n\t\t\t\tif (_SWConstants.camera.fov > _SWConstants.c_Minfov) {\n\n\t\t\t\t\tthis.dollyOut((_SWConstants.c_Maxfov - _SWConstants.c_Minfov) / 3); //放大\n\t\t\t\t} else if (_SWConstants.camera.fov == _SWConstants.c_Minfov) {\n\n\t\t\t\t\tthis.dollyIn(100); //还原\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 这个是直接设置相机视角值\r\n   * @param {*} yaws 经度\r\n   * @param {*} pitch 纬度\r\n   * @param {*} updatas 更新坐标\r\n   */\n\n\t}, {\n\t\tkey: 'setHousesViewAngle',\n\t\tvalue: function setHousesViewAngle(yaws, pitch, updatas) {\n\t\t\tif (this.yaw_Camera == (0, _SWTool.getNumberMax360)(yaws) && this.picth_Camera == pitch) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (yaws) this.yaw_Camera = (0, _SWTool.getNumberMax360)(yaws);\n\n\t\t\tif (pitch) this.picth_Camera = pitch;\n\n\t\t\tif (updatas) {\n\t\t\t\tthis.config.yaw = this.yaw_Camera;\n\t\t\t\tthis.config.pitch = this.picth_Camera;\n\t\t\t}\n\n\t\t\tthis.store.dispatch((0, _action.show_PanoMap_fun)({\n\t\t\t\tradarAngle: this.yaw_Camera\n\t\t\t}));\n\n\t\t\t_SWConstants.camera.lookAt((0, _SWTool.YPRToVector3)(this.yaw_Camera, this.picth_Camera));\n\n\t\t\tif (this.ifCameraEnlarge) {\n\t\t\t\t_SWConstants.sw_skyBox.panoBox.addFaceTiles();\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * 叠加相机角度\r\n   * @param {*} yaws 经度\r\n   * @param {*} pitch 纬度\r\n   */\n\n\t}, {\n\t\tkey: 'setOverlayViewAngle',\n\t\tvalue: function setOverlayViewAngle(yaws, pitch) {\n\t\t\t// let picthCamera = this.picth_Camera + pitch;\n\n\t\t\tvar yawCamera = (0, _SWTool.getNumberMax360)(this.yaw_Camera + yaws);\n\n\t\t\tthis.setHousesViewAngle(yawCamera, pitch, true);\n\t\t}\n\t}]);\n\n\treturn SWCameraModule;\n}();\n\nexports.default = SWCameraModule;",null]}