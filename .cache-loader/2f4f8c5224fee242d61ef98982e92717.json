{"remainingRequest":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js??ref--5-0!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","dependencies":[{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\module\\SWCameraModule.js","mtime":1531468139737},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\.babelrc","mtime":1526554899270},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1526631545426},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js","mtime":1519638534000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global THREE*/\n\nvar _SWConstants = require('../tool/SWConstants');\n\nvar _SWTool = require('../tool/SWTool');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TWEEN = require('@tweenjs/tween.js');\n\n/**\r\n * 相机控制类只有旋转和缩放，没有平移\r\n */\n\nvar SWCameraModule = function () {\n        function SWCameraModule() {\n                _classCallCheck(this, SWCameraModule);\n\n                /**相机状态枚举 */\n                this.STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\n\n                /**相机目前状态 */\n                this.state = this.STATE.NONE;\n\n                /**鼠标按钮 */\n                this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n                //这个选项实际上可以使进出进入; 为了向后兼容，保留为“缩放”。\n                /**设置为false以禁用缩放 */\n                this.enableZoom = true;\n                /**缩放速度 */\n                this.zoomSpeed = 4.0;\n\n                /**设置为false以禁用旋转 */\n                this.enableRotate = true;\n                /**旋转速度 */\n                this.rotateSpeed = 0.4;\n\n                /**自动旋转 */\n                this.autoRotate = true;\n                /**自动旋转速度，当fps为60时，每轮30秒 */\n                this.autoRotateSpeed = 2.0;\n\n                //设置为true以启用阻尼（惯性）\n                //如果启用阻尼，则必须在动画循环中调用controls.update（）\n                this.enableDamping = false;\n                this.dampingFactor = 0.25;\n                this.dampingTime = 0;\n\n                //旋转坐标值\n                this.rotateStart = new THREE.Vector2();\n                this.rotateEnd = new THREE.Vector2();\n                this.rotateDelta = new THREE.Vector2();\n\n                this.startTime = undefined;\n                this.speed = { yaw: 0, pitch: 0 };\n\n                //缩放坐标值\n                this.dollyStart = new THREE.Vector2();\n                this.dollyEnd = new THREE.Vector2();\n                this.dollyDelta = new THREE.Vector2();\n\n                this.rotateYaw = 0;\n                this.rotatePitch = 0;\n\n                //围绕Y轴旋转，也叫偏航角\n                this.yaw_Camera = 0;\n                //围绕X轴旋转，也叫做俯仰角\n                this.picth_Camera = 0;\n                //围绕Z轴旋转，也叫翻滚角\n                this.roll_Camera = 0;\n\n                /**是否启用陀螺仪 */\n                this.enabledGyro = true;\n\n                this.deviceOrientation = {};\n                this.screenOrientation = 0;\n\n                this.alphaOffset = 0; // radians\n\n                this.zee = new THREE.Vector3(0, 0, 1);\n\n                this.euler = new THREE.Euler();\n\n                this.q0 = new THREE.Quaternion();\n\n                this.q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\n                this.startAlpha = 0;\n                this.startBeta = 0;\n                this.startGamma = 0;\n\n                this.lon = this.lat = 0;\n                this.moothFactor = 10;\n                this.boundary = 320;\n                this.lastLon = this.lastLat = undefined;\n\n                /**相机是否推进放大 */\n                this.ifCameraEnlarge = false;\n\n                this.setHousesViewAngle(0, 0);\n        }\n\n        _createClass(SWCameraModule, [{\n                key: 'update',\n                value: function update() {\n\n                        if (this.enableDamping) {\n\n                                this.speed.yaw = this.getAutoRotationAngle(this.speed.yaw);\n\n                                this.speed.pitch = this.getAutoRotationAngle(this.speed.pitch);\n\n                                if (Math.abs(this.speed.yaw) <= 0.2 && Math.abs(this.speed.pitch) <= 0.2) {\n\n                                        this.enableDamping = false;\n\n                                        return;\n                                }\n\n                                this.setOverlayViewAngle(parseFloat(this.speed.yaw.toFixed(2)), Math.floor(this.speed.pitch));\n                        }\n                }\n\n                /**获得自动旋转角度 */\n\n        }, {\n                key: 'getAutoRotationAngle',\n                value: function getAutoRotationAngle(speed) {\n                        if (speed !== 0) {\n                                if (speed > 0) {\n                                        speed -= this.dampingFactor;\n                                        speed < 0 && (speed = 0);\n                                } else {\n                                        speed += this.dampingFactor;\n                                        speed > 0 && (speed = 0);\n                                }\n                        }\n                        return speed;\n                }\n\n                /**设置缩放比例 */\n\n        }, {\n                key: 'getZoomScale',\n                value: function getZoomScale() {\n                        return Math.pow(2, this.zoomSpeed);\n                }\n\n                /**缩小 */\n\n        }, {\n                key: 'dollyIn',\n                value: function dollyIn(dollyScale) {\n\n                        if (_SWConstants.camera.isPerspectiveCamera) {\n\n                                var fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov + dollyScale));\n\n                                if (_SWConstants.camera.fov > (_SWConstants.c_Maxfov + _SWConstants.c_Minfov) * 0.5) {\n\n                                        this.ifCameraEnlarge = false;\n\n                                        _SWConstants.sw_skyBox.panoBox.clearFaceTiles();\n                                }\n\n                                var from = { x: _SWConstants.camera.fov };\n\n                                var to = { x: fov };\n\n                                new TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n                                        _SWConstants.camera.fov = this._object.x;\n                                }).onComplete(function () {}).start();\n\n                                _SWConstants.camera.updateProjectionMatrix();\n                        }\n                }\n\n                /**放大 */\n\n        }, {\n                key: 'dollyOut',\n                value: function dollyOut(dollyScale) {\n\n                        if (_SWConstants.camera.isPerspectiveCamera) {\n\n                                var fov = Math.max(_SWConstants.c_Minfov, Math.min(_SWConstants.c_Maxfov, _SWConstants.camera.fov - dollyScale));\n\n                                _SWConstants.camera.updateProjectionMatrix();\n\n                                if (_SWConstants.camera.fov < (_SWConstants.c_Maxfov + _SWConstants.c_Minfov) * 0.5) {\n\n                                        this.ifCameraEnlarge = true;\n\n                                        _SWConstants.sw_skyBox.panoBox.addFaceTiles();\n                                }\n\n                                var from = { x: _SWConstants.camera.fov };\n\n                                var to = { x: fov };\n\n                                new TWEEN.Tween(from).to(to, 800).easing(TWEEN.Easing.Quadratic.Out).onUpdate(function () {\n                                        _SWConstants.camera.fov = this._object.x;\n                                }).onComplete(function () {}).start();\n                        }\n                }\n\n                /**\r\n                 * 鼠标按下\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onMouseDown',\n                value: function onMouseDown(event) {\n\n                        event.preventDefault();\n\n                        if (event.button == this.mouseButtons.ORBIT) {\n\n                                if (this.enableRotate === false) return;\n\n                                this.rotateStart.set(event.clientX, event.clientY);\n\n                                this.startTime = Date.now();\n\n                                this.state = this.STATE.ROTATE;\n                        }\n                }\n\n                /**\r\n                 * 鼠标移动\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onMouseMove',\n                value: function onMouseMove(event) {\n\n                        event.preventDefault();\n\n                        if (this.state == this.STATE.ROTATE) {\n\n                                if (this.enableRotate === false) return;\n\n                                this.rotateEnd.set(event.clientX, event.clientY);\n\n                                this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\n\n                                this.rotateYaw = THREE.Math.radToDeg(2 * Math.PI * this.rotateDelta.x / window.innerWidth); // 显示区域\n\n                                this.rotatePitch = THREE.Math.radToDeg(2 * Math.PI * this.rotateDelta.y / window.innerHeight);\n\n                                this.setOverlayViewAngle(this.rotateYaw, this.rotatePitch);\n\n                                this.slowMove(10);\n\n                                this.rotateStart.copy(this.rotateEnd);\n                        }\n                }\n\n                /**\r\n                 * 鼠标弹起,旋转拖尾效果\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onMouseUp',\n                value: function onMouseUp(event) {\n\n                        this.state = this.STATE.NONE;\n                }\n\n                /**\r\n                 * 滚轮缩放\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onMouseWheel',\n                value: function onMouseWheel(event) {\n\n                        if (this.enableZoom === false || this.state !== this.STATE.NONE && this.state !== this.STATE.ROTATE) return;\n\n                        event.preventDefault();\n                        event.stopPropagation();\n\n                        if (event.deltaY < 0) {\n\n                                this.dollyOut(this.getZoomScale());\n                        } else if (event.deltaY > 0) {\n\n                                this.dollyIn(this.getZoomScale());\n                        }\n                }\n\n                /**\r\n                 * 手指按下\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onTouchStart',\n                value: function onTouchStart(event) {\n\n                        event.preventDefault();\n\n                        switch (event.touches.length) {\n\n                                case 1:\n                                        // 单指触摸：旋转\n\n                                        if (this.enableRotate === false) return;\n\n                                        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n                                        this.startTime = Date.now();\n\n                                        this.state = this.STATE.TOUCH_ROTATE;\n\n                                        break;\n\n                                case 2:\n                                        // 双指触摸：移动/缩放\n\n                                        if (this.enableZoom === false && this.enablePan === false) return;\n\n                                        if (this.enableZoom) {\n\n                                                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                                                var dy = event.touches[0].pageY - event.touches[1].pageY;\n\n                                                var distance = Math.sqrt(dx * dx + dy * dy);\n\n                                                this.dollyStart.set(0, distance);\n                                        }\n\n                                        this.state = this.STATE.TOUCH_DOLLY_PAN;\n\n                                        break;\n\n                                default:\n                                        this.state = this.STATE.NONE;\n\n                        }\n                }\n\n                /**\r\n                 * 手指移动\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onTouchMove',\n                value: function onTouchMove(event) {\n\n                        event.preventDefault();\n                        event.stopPropagation();\n\n                        switch (event.touches.length) {\n\n                                case 1:\n                                        // 单指触摸：旋转\n\n                                        if (this.enableRotate === false || this.state !== this.STATE.TOUCH_ROTATE) return;\n\n                                        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n                                        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\n\n                                        this.rotateYaw = THREE.Math.radToDeg(2 * Math.PI * this.rotateDelta.x / window.innerWidth); // 显示区域\n\n                                        this.rotatePitch = THREE.Math.radToDeg(2 * Math.PI * this.rotateDelta.y / window.innerHeight);\n\n                                        this.setOverlayViewAngle(parseFloat(this.rotateYaw.toFixed(2)), Math.floor(this.rotatePitch));\n\n                                        this.slowMove(20);\n\n                                        this.rotateStart.copy(this.rotateEnd);\n\n                                        break;\n\n                                case 2:\n                                        // 双指触摸：移动/缩放\n\n                                        if (this.enableZoom === false || this.state !== this.STATE.TOUCH_DOLLY_PAN) return;\n\n                                        var dx = event.touches[0].pageX - event.touches[1].pageX;\n                                        var dy = event.touches[0].pageY - event.touches[1].pageY;\n\n                                        var distance = Math.sqrt(dx * dx + dy * dy);\n\n                                        this.dollyEnd.set(0, distance);\n\n                                        this.dollyDelta.set(0, -(this.dollyEnd.y - this.dollyStart.y) * 0.5 / this.zoomSpeed);\n\n                                        this.dollyIn(this.dollyDelta.y);\n\n                                        this.dollyStart.copy(this.dollyEnd);\n                                        break;\n\n                                default:\n\n                                        this.state = this.STATE.NONE;\n                        }\n                }\n\n                /**\r\n                 * 手指弹起\r\n                 * @param {MouseEvent} event \r\n                 */\n\n        }, {\n                key: 'onTouchEnd',\n                value: function onTouchEnd(event) {\n\n                        if (event.touches.length === 1) {\n\n                                this.state = this.STATE.TOUCH_ROTATE;\n\n                                this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n                                this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                        } else if (event.touches.length === 0) {\n\n                                this.state = this.STATE.NONE;\n                        }\n                }\n\n                /**\r\n                 * 帮助转动，使转动更加轻松\r\n                 * @param {Number} card 缓动值\r\n                 */\n\n        }, {\n                key: 'slowMove',\n                value: function slowMove(card) {\n\n                        this.speed = { yaw: this.rotateEnd.x - this.rotateStart.x, pitch: this.rotateEnd.y - this.rotateStart.y };\n\n                        this.dampingTime = (Date.now() - this.startTime) / card;\n\n                        var yy = this.speed.yaw / this.dampingTime > 0 ? this.speed.yaw / this.dampingTime > 8 ? 8 : this.speed.yaw / this.dampingTime : this.speed.yaw / this.dampingTime < -8 ? -8 : this.speed.yaw / this.dampingTime;\n\n                        var pp = this.speed.pitch / this.dampingTime > 0 ? this.speed.pitch / this.dampingTime > 3 ? 3 : this.speed.pitch / this.dampingTime : this.speed.pitch / this.dampingTime < -3 ? -3 : this.speed.pitch / this.dampingTime;\n\n                        this.speed = { yaw: yy, pitch: pp };\n\n                        this.enableDamping = true;\n                }\n\n                /**\r\n                 * 监听并接收设备方向变化信息,检测手机倾斜旋转\r\n                 *         z   \r\n                 *         |   y\r\n                 *         |  /   \r\n                 *         | /\r\n                 *          ————————X\r\n                 * @param {*} event \r\n                 */\n\n        }, {\n                key: 'onDeviceOrientationChangeEvent',\n                value: function onDeviceOrientationChangeEvent(event) {\n                        if (this.enabledGyro) {\n\n                                if (event) {\n\n                                        var alpha = event.alpha ? THREE.Math.degToRad(parseFloat((event.alpha - this.startAlpha).toFixed(2))) + this.alphaOffset : 0; // Z\n\n                                        var beta = event.beta ? THREE.Math.degToRad(parseFloat((event.beta - this.startBeta).toFixed(2))) : 0; // X'\n\n                                        var gamma = event.gamma ? THREE.Math.degToRad(parseFloat(event.gamma.toFixed(2))) : 0; // Y''\n\n                                        var orient = this.screenOrientation ? THREE.Math.degToRad(this.screenOrientation) : 0; // O\n\n                                        this.setObjectQuaternion(_SWConstants.camera.quaternion, alpha, beta, gamma, orient);\n                                }\n                        }\n                }\n\n                /**\r\n                 * 浏览器横竖屏切换检测\r\n                 */\n\n        }, {\n                key: 'onScreenOrientationChangeEvent',\n                value: function onScreenOrientationChangeEvent() {\n\n                        this.screenOrientation = window.orientation || 0;\n                }\n\n                /**\r\n                 * 重新定义相机的四元素\r\n                 * @param {Quaternion} quaternion 相机的旋转四元素\r\n                 * @param {Number} alpha 设备沿 Z 轴旋转的弧度值\r\n                 * @param {Number} beta 设备在 x 轴上的旋转弧度值\r\n                 * @param {Number} gamma 设备在 y 轴上的旋转弧度值\r\n                 * @param {Number} orient 浏览器横竖屏朝向的弧度值\r\n                 */\n\n        }, {\n                key: 'setObjectQuaternion',\n                value: function setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {\n\n                        this.euler.set(beta, alpha, -gamma, 'YXZ'); //欧拉角是绕坐标轴旋转的角度和顺序,按照heading , pitch , roll 的顺序，应该是 YXZ\n\n                        quaternion.setFromEuler(this.euler); // 从欧拉角设置四元数\n\n                        quaternion.multiply(this.q1); //四元数的乘法\n\n                        quaternion.multiply(this.q0.setFromAxisAngle(this.zee, -orient)); // 从任意轴的旋转角设置四元数\n                }\n\n                /**\r\n                 * 有激光点云时点击墙面会放大\r\n                 */\n\n        }, {\n                key: 'setWallWheel',\n                value: function setWallWheel() {\n                        if (_SWConstants.camera.isPerspectiveCamera) {\n\n                                if (_SWConstants.camera.fov > _SWConstants.c_Minfov) {\n                                        //放大\n\n                                        this.dollyOut((_SWConstants.c_Maxfov - _SWConstants.c_Minfov) / 3);\n                                } else if (_SWConstants.camera.fov == _SWConstants.c_Minfov) {\n                                        //还原\n\n                                        this.dollyIn(100);\n                                }\n                        }\n                }\n\n                /**\r\n                 * 这个是直接设置相机视角值\r\n                 * @param {*} yaws 经度\r\n                 * @param {*} pitch 纬度\r\n                 */\n\n        }, {\n                key: 'setHousesViewAngle',\n                value: function setHousesViewAngle(yaws, pitch) {\n\n                        if (yaws) this.yaw_Camera = yaws;\n\n                        if (pitch) this.picth_Camera = pitch;\n\n                        _SWConstants.camera.lookAt((0, _SWTool.YPRToVector3)(this.yaw_Camera, this.picth_Camera));\n\n                        if (this.ifCameraEnlarge) {\n\n                                _SWConstants.sw_skyBox.panoBox.addFaceTiles();\n                        }\n                }\n\n                /**\r\n                 * 叠加相机角度\r\n                 * @param {*} yaws 经度\r\n                 * @param {*} pitch 纬度\r\n                 */\n\n        }, {\n                key: 'setOverlayViewAngle',\n                value: function setOverlayViewAngle(yaws, pitch) {\n\n                        this.picth_Camera = Math.max(_SWConstants.c_minPitch, Math.min(_SWConstants.c_maxPitch, this.picth_Camera + pitch));\n\n                        this.yaw_Camera = (0, _SWTool.getNumberMax360)(this.yaw_Camera + yaws);\n\n                        if (isNaN(this.picth_Camera)) this.picth_Camera = 0;\n\n                        if (isNaN(this.yaw_Camera)) this.yaw_Camera = 0;\n\n                        this.setHousesViewAngle();\n                }\n        }]);\n\n        return SWCameraModule;\n}();\n\nexports.default = SWCameraModule;",null]}