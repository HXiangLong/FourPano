{"remainingRequest":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js??ref--5-0!D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\tool\\Tool.js","dependencies":[{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\app\\src\\tool\\Tool.js","mtime":1514945775779},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\.babelrc","mtime":1526554899270},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1526631545426},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\babel-loader\\lib\\index.js","mtime":1520329890000},{"path":"D:\\02数文\\WebProject\\NodeAllProject\\FourPano\\node_modules\\eslint-loader\\index.js","mtime":1519638534000}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSceneToWorld = getSceneToWorld;\nexports.getWorldToScene = getWorldToScene;\nexports.Vector3ToVP = Vector3ToVP;\nexports.VPToVector3 = VPToVector3;\nexports.getNumberMax360 = getNumberMax360;\nexports.getDistance = getDistance;\nexports.getHfov = getHfov;\nexports.getWfov = getWfov;\nexports.getFaceTileMatrixWH = getFaceTileMatrixWH;\nexports.getPintIFScene = getPintIFScene;\nexports.getRandomColor = getRandomColor;\nexports.getWallProbeSurfaceAngle = getWallProbeSurfaceAngle;\nexports.getProbeSurfaceDistance = getProbeSurfaceDistance;\nexports.getPanoRealPoint = getPanoRealPoint;\nexports.getWallRealPoint = getWallRealPoint;\nexports.getJudgeOrZoom = getJudgeOrZoom;\nexports.getArrowsAngle = getArrowsAngle;\nexports.disposeNode = disposeNode;\nexports.delectTextDiv = delectTextDiv;\nexports.getFullScreen = getFullScreen;\nexports.TextDiv = TextDiv;\nexports.TextureAnimator = TextureAnimator;\n\nvar _Constants = require('./Constants');\n\nvar constants = _interopRequireWildcard(_Constants);\n\nvar _SWViewGesture = require('./SWViewGesture');\n\nvar _SWViewGesture2 = _interopRequireDefault(_SWViewGesture);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * 屏幕坐标转世界坐标\r\n * @param {number} dx 鼠标X坐标\r\n * @param {number} dy 鼠标Y坐标\r\n */\nfunction getSceneToWorld(dx, dy) {\n    var projector = new THREE.Projector();\n    var mouse3D = new THREE.Vector3(dx / window.innerWidth * 2 - 1, -dy / window.innerHeight * 2 + 1, 0.5);\n    projector.unprojectVector(mouse3D, camera);\n    mouse3D.sub(camera.position);\n    mouse3D.normalize();\n    return mouse3D;\n};\n\n/**\r\n * 世界坐标转屏幕坐标\r\n * @param {THREE.Vector3} v3 世界坐标\r\n */\nfunction getWorldToScene(v3) {\n    var vector = v3.clone();\n    var windowWidth = window.innerWidth;\n    var minWidth = 1280;\n\n    if (windowWidth < minWidth) {\n        windowWidth = minWidth;\n    }\n\n    var widthHalf = windowWidth / 2;\n    var heightHalf = window.innerHeight / 2;\n\n    vector.project(camera);\n\n    vector.x = vector.x * widthHalf + widthHalf;\n    vector.y = -(vector.y * heightHalf) + heightHalf;\n\n    return vector;\n};\n\n/**\r\n * 三维坐标转视点坐标\r\n * @param {THREE.Vector3} v3 \r\n */\nfunction Vector3ToVP(v3) {\n    var yaw = Math.atan2(v3.x, v3.z);\n    var pitch = Math.atan2(v3.y, v3.x / Math.sin(yaw));\n    yaw = THREE.Math.radToDeg(yaw);\n    if (yaw < 0) {\n        yaw = 360 + yaw;\n    }\n    yaw = (yaw + 90) % 360;\n    var swvg = new _SWViewGesture2.default(yaw, THREE.Math.radToDeg(pitch), 0);\n    return swvg;\n};\n\n/**\r\n * 视点转三维坐标\r\n * @param {SWViewGesture} vp \r\n */\nfunction VPToVector3(vp) {\n    var vec = new THREE.Vector3(0, 0, 0);\n    vec.y = Math.sin(THREE.Math.degToRad(vp.getPitch())) * constants.c_FaceDistance * 0.5;\n    var m = Math.cos(THREE.Math.degToRad(vp.getPitch())) * constants.c_FaceDistance * 0.5;\n    vec.x = Math.sin(THREE.Math.degToRad(vp.getYaw() - 90)) * m;\n    vec.z = Math.cos(THREE.Math.degToRad(vp.getYaw() - 90)) * m;\n    return vec;\n};\n\n/**\r\n * 让数值在0~360之间\r\n * @param {number} n \r\n */\nfunction getNumberMax360(n) {\n    n = n % 360;\n    if (n < 0) {\n        n = 360 + n;\n    }\n    return n;\n};\n\n/**\r\n * 两点距离\r\n * @param {number} x1 \r\n * @param {number} y1 \r\n * @param {number} x2 \r\n * @param {number} y2 \r\n */\nfunction getDistance(x1, y1, x2, y2) {\n    var xx = x2 - x1;\n    var yy = y2 - y1;\n    return Math.pow(xx * xx + yy * yy, 0.5);\n};\n\n/**\r\n * 通过水平fov获得垂直fov\r\n * @param {number} wfov \r\n * @param {number} aspect \r\n */\nfunction getHfov(wfov, aspect) {\n    return THREE.Math.radToDeg(Math.atan(Math.tan(THREE.Math.degToRad(wfov) / 2) / aspect) * 2);\n};\n\n/**\r\n * 通过垂直fov获得水平fov\r\n * @param {number} hfov \r\n * @param {number} aspect \r\n */\nfunction getWfov(hfov, aspect) {\n    return THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(hfov) / 2) * aspect));\n};\n\n/**\r\n * 获取当前面当前放大值瓦片WH数\r\n * @param {number} lzoom \r\n */\nfunction getFaceTileMatrixWH(lzoom) {\n    var wh = new THREE.Vector3();\n    wh.x = wh.y = Math.pow(2, lzoom);\n    return wh;\n};\n\n/**\r\n * 获取点是否在屏幕上\r\n * @param {THREE.Vector3} sceneXY \r\n */\nfunction getPintIFScene(sceneXY) {\n    var boo = false;\n    if (Math.abs(sceneXY.x) != Infinity && sceneXY.x != NaN && sceneXY.x >= -100 && sceneXY.x <= window.innerWidth + 100 && Math.abs(sceneXY.y) != Infinity && sceneXY.y != NaN && window.innerHeight - sceneXY.y >= -100 && window.innerHeight - sceneXY.y <= window.innerHeight + 100 && Math.abs(sceneXY.z) != Infinity && sceneXY.z != NaN && sceneXY.z < 1) {\n        boo = true;\n    }\n    return boo;\n};\n\n/**\r\n * 获取随机颜色值\r\n * */\nfunction getRandomColor() {\n    return '#' + (Math.random() * 0xffffff << 0).toString(16);\n};\n\n/**\r\n * 墙面探面角度值\r\n * @param {THREE.Object} obj \r\n */\nfunction getWallProbeSurfaceAngle(obj) {\n    var normal = obj.face.normal.clone();\n    var vv = new THREE.Vector3(0, 0, 1);\n    var angle = THREE.Math.radToDeg(vv.angleTo(normal));\n    var tan = vv.clone().cross(normal).dot(new THREE.Vector3(0, 1, 0));\n    if (tan > 0) {\n        angle = 360 - angle;\n    }\n    return angle;\n};\n\n/**\r\n * 获取显示的距离\r\n * @param {THREE.Object} obj \r\n */\nfunction getProbeSurfaceDistance(obj) {\n    return Math.abs(1.5 * obj.distance / obj.point.y);\n};\n\n/**\r\n * 获取现实中的坐标\r\n * @param {THREE.Object} obj \r\n * @param {number} rph \r\n */\nfunction getPanoRealPoint(obj, rph) {\n    var v = Math.asin(obj.point.y / obj.distance); //垂直角度\n    var h = Math.atan2(obj.point.z, obj.point.x) - THREE.Math.degToRad(90); //水平角度\n\n    var rp = Math.abs(rph / Math.tan(v));\n    var x = rp * Math.cos(h);\n    var z = -rp * Math.sin(h);\n    var y = rph;\n    var v3 = new THREE.Vector3(x, y, z).applyMatrix4(constants.c_OpenGLToDS3Mx4);\n    var realPoint = constants.c_StationInfo.point.clone().add(v3);\n    return realPoint;\n};\n\n/**\r\n * 获得墙面点击的真实坐标\r\n * @param {THREE.Object} obj \r\n */\nfunction getWallRealPoint(obj) {\n    var drc = obj.point.clone().applyMatrix4(obj.object.matrix).applyMatrix4(constants.c_OpenGLToDS3Mx4);\n    var dx = drc.x / constants.c_WallDisplaySize * 2;\n    var dy = drc.y / constants.c_WallDisplaySize * 2;\n    var dz = drc.z / constants.c_WallDisplaySize * 2;\n    var realPoint = constants.c_StationInfo.point.clone().add(new THREE.Vector3(dx, dy, dz));\n    return realPoint;\n};\n\n/**\r\n * 获取是否跳转还是放大\r\n * @param {THREE.Object} obj \r\n * @param {int} type \r\n */\nfunction getJudgeOrZoom(obj, type) {\n    var distances;\n    var dis = 0;\n    if (type == 1) {\n        distances = getPanoRealPoint(obj, 2.5);\n        dis = -1;\n    } else {\n        distances = getWallRealPoint(obj);\n    }\n    var dis0 = Math.sqrt(Math.pow(distances.x - constants.c_StationInfo.nx, 2) + Math.pow(distances.y - constants.c_StationInfo.ny, 2)) + dis;\n    for (var i = 0; i < constants.c_AdjacentPanoInfoArr.length; i++) {\n        var dis1 = Math.sqrt(Math.pow(distances.x - constants.c_AdjacentPanoInfoArr[i].nX, 2) + Math.pow(distances.y - constants.c_AdjacentPanoInfoArr[i].nY, 2));\n        if (dis1 <= dis0) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\r\n * 获取两个站点坐标点的夹角\r\n * @param v1 当前站点\r\n * @param v2 下一站点\r\n * */\nfunction getArrowsAngle(v1, v2) {\n    var p2 = new THREE.Vector3(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z).applyMatrix4(constants.c_DS3ToOpenGLMx4);\n    var v4 = new THREE.Vector3(-1, 0, 0);\n    var angle = p2.angleTo(v4);\n    angle = THREE.Math.radToDeg(angle); //转换为角度\n    var tan = p2.clone().cross(v4).dot(new THREE.Vector3(0, 1, 0));\n    if (tan > 0) {\n        angle = 360 - angle;\n    }\n    return angle;\n};\n\n/**\r\n * 清空对象缓存\r\n * @param node 对象\r\n * @param ifParent 是否用父类删除自己\r\n * */\nfunction disposeNode(node) {\n    var ifParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (node instanceof THREE.Mesh || node instanceof THREE.Sprite || node instanceof THREE.Line || node instanceof THREE.BoxHelper) {\n        if (node.geometry) {\n            node.geometry.dispose();\n        }\n        if (node.material) {\n            if (node.material instanceof THREE.MeshFaceMaterial || node.material instanceof THREE.MultiMaterial) {\n                $.each(node.material.materials, function (idx, mtrl) {\n                    if (mtrl.map) mtrl.map.dispose();\n                    if (mtrl.lightMap) mtrl.lightMap.dispose();\n                    if (mtrl.bumpMap) mtrl.bumpMap.dispose();\n                    if (mtrl.normalMap) mtrl.normalMap.dispose();\n                    if (mtrl.specularMap) mtrl.specularMap.dispose();\n                    if (mtrl.envMap) mtrl.envMap.dispose();\n\n                    mtrl.dispose(); // disposes any programs associated with the material\n                });\n            } else {\n                if (node.material.map) node.material.map.dispose();\n                if (node.material.lightMap) node.material.lightMap.dispose();\n                if (node.material.bumpMap) node.material.bumpMap.dispose();\n                if (node.material.normalMap) node.material.normalMap.dispose();\n                if (node.material.specularMap) node.material.specularMap.dispose();\n                if (node.material.envMap) node.material.envMap.dispose();\n\n                node.material.dispose(); // disposes any programs associated with the material\n            }\n        }\n        if (ifParent) {\n            if (node.parent) {\n                node.parent.remove(node);\n            }\n            node = null;\n        }\n    }\n};\n\n/**\r\n * 清楚新增文本div层\r\n * @param {*} textdiv \r\n */\nfunction delectTextDiv(textdiv) {\n    if (textdiv && document.body.children.indexOf(textdiv) != -1) {\n        document.body.removeChild(textdiv);\n    }\n};\n\n/**\r\n * 全屏\r\n * */\nfunction getFullScreen() {\n    if (!document.fullscreenElement // alternative standard method\n    && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {\n        // current working methods\n        if (document.documentElement.requestFullscreen) {\n            document.documentElement.requestFullscreen();\n        } else if (document.documentElement.msRequestFullscreen) {\n            document.documentElement.msRequestFullscreen();\n        } else if (document.documentElement.mozRequestFullScreen) {\n            document.documentElement.mozRequestFullScreen();\n        } else if (document.documentElement.msRequestFullscreen) {\n            //IE11\n            document.documentElement.msRequestFullscreen();\n        } else if (document.documentElement.webkitRequestFullscreen) {\n            document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n        }\n    } else {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n        }\n    }\n};\n\n/**\r\n * DIV文本显示\r\n * @param {*} labelPos \r\n * @param {*} fontSize \r\n * @param {*} text \r\n */\nfunction TextDiv(labelPos, fontSize, text) {\n    labelPos.copy(getWorldToScene(labelPos));\n    this.textDiv = document.createElement(\"div\");\n    var fs = fontSize || 14;\n    this.textDiv.style.fontSize = fs + \"px\";\n    this.textDiv.style.color = \"#fff\";\n    this.textDiv.style.position = \"absolute\";\n    this.textDiv.id = \"\" + text;\n    this.textDiv.style.pointerEvents = \"none\";\n    if (!text) {\n        this.textDiv.style.left = \"-100px\";\n        this.textDiv.style.top = \"-100px\";\n    } else {\n        this.textDiv.style.left = labelPos.x + \"px\";\n        this.textDiv.style.top = labelPos.y + \"px\";\n    }\n    this.textDiv.innerHTML = text;\n    document.body.appendChild(this.textDiv);\n    return this.textDiv;\n}\n\n/**\r\n * GIF动画\r\n * @param {THREE.Texture} texture 贴图对象\r\n * @param {number} tilesHoriz 横向\r\n * @param {number} tilesVert 竖向\r\n * @param {number} numTiles 数量\r\n * @param {number} tileDispDuration 间隔时间 \r\n */\nfunction TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {\n    this.tilesHorizontal = tilesHoriz;\n    this.tilesVertical = tilesVert;\n    this.numberOfTiles = numTiles;\n    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n    texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);\n    this.tileDisplayDuration = tileDispDuration;\n    this.currentDisplayTime = 0;\n    this.currentTile = 0;\n\n    this.update = function (milliSec) {\n        this.currentDisplayTime += milliSec;\n        while (this.currentDisplayTime > this.tileDisplayDuration) {\n            this.currentDisplayTime -= this.tileDisplayDuration;\n            this.currentTile++;\n            if (this.currentTile == this.numberOfTiles) this.currentTile = 0;\n            var currentColumn = this.currentTile % this.tilesHorizontal;\n            texture.offset.x = currentColumn / this.tilesHorizontal;\n            var currentRow = Math.floor(this.currentTile / this.tilesHorizontal);\n            texture.offset.y = currentRow / this.tilesVertical;\n        }\n    };\n}",null]}